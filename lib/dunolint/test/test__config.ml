(*********************************************************************************)
(*  Dunolint - A tool to lint and help manage files in dune projects             *)
(*  Copyright (C) 2024-2025 Mathieu Barbin <mathieu.barbin@gmail.com>            *)
(*                                                                               *)
(*  This file is part of Dunolint.                                               *)
(*                                                                               *)
(*  Dunolint is free software; you can redistribute it and/or modify it          *)
(*  under the terms of the GNU Lesser General Public License as published by     *)
(*  the Free Software Foundation either version 3 of the License, or any later   *)
(*  version, with the LGPL-3.0 Linking Exception.                                *)
(*                                                                               *)
(*  Dunolint is distributed in the hope that it will be useful, but WITHOUT      *)
(*  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or        *)
(*  FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License  *)
(*  and the file `NOTICE.md` at the root of this repository for more details.    *)
(*                                                                               *)
(*  You should have received a copy of the GNU Lesser General Public License     *)
(*  and the LGPL-3.0 Linking Exception along with this library. If not, see      *)
(*  <http://www.gnu.org/licenses/> and <https://spdx.org>, respectively.         *)
(*********************************************************************************)

open Dunolint.Config.Std

let%expect_test "creat" =
  let t = Dunolint.Config.create () in
  print_s [%sexp (t : Dunolint.Config.t)];
  [%expect {| (stanzas (lang dunolint 1.0)) |}];
  require_equal [%here] (module Dunolint.Config) t t;
  [%expect {||}];
  ()
;;

let%expect_test "empty v1" =
  let t = Dunolint.Config.V1.create [] in
  print_s [%sexp (Dunolint.Config.V1.skip_paths t : Dunolint.Glob.t list list)];
  [%expect {| () |}];
  print_s [%sexp (Dunolint.Config.V1.rules t : Dunolint.Config.Rule.t list)];
  [%expect {| () |}];
  let t = Dunolint.Config.v1 t in
  print_s [%sexp (t : Dunolint.Config.t)];
  [%expect {| (stanzas (lang dunolint 1.0)) |}];
  require_equal [%here] (module Dunolint.Config) t t;
  [%expect {||}];
  ()
;;

let%expect_test "non-empty-v1" =
  let t =
    Dunolint.Config.V1.create
      [ `skip_paths [ Dunolint.Glob.v ".git/" ]
      ; `rule (enforce (dune (has_field `instrumentation)))
      ]
    |> Dunolint.Config.v1
  in
  let v1 =
    match Dunolint.Config.Private.view t with
    | `v0 _ -> assert false
    | `v1 v1 -> v1
  in
  print_s [%sexp (Dunolint.Config.V1.rules v1 : Dunolint.Config.Rule.t list)];
  [%expect {| ((enforce (dune (has_field instrumentation)))) |}];
  print_s [%sexp (t : Dunolint.Config.t)];
  [%expect
    {|
    (stanzas
      (lang dunolint 1.0)
      (skip_paths .git/)
      (rule (enforce (dune (has_field instrumentation)))))
    |}];
  require_equal [%here] (module Dunolint.Config) t t;
  [%expect {||}];
  let rules = Dunolint.Config.V1.rules v1 in
  let t' = Dunolint.Config.create ~rules () in
  require_equal [%here] (module Int) 1 (Dunolint.Config.compare t t');
  ()
;;

let test_roundtrip c =
  let sexps = Dunolint.Config.to_stanzas c in
  let c' = Dunolint.Config.of_stanzas sexps in
  require_equal [%here] (module Dunolint.Config) c c';
  List.iter sexps ~f:print_s;
  ()
;;

let%expect_test "versioned_sexp v0" =
  let v0 = Dunolint.Config.V0.create () in
  let t = Dunolint.Config.v0 v0 in
  test_roundtrip t;
  [%expect {| ((version 0) ((rules ()))) |}];
  print_endline (Dunolint.Config.to_file_contents t ~generated_by:"test_config.ml");
  [%expect
    {|
    ;; This file is generated by [test_config.ml]. Do not edit!
    ((version 0) ((rules ())))
    |}];
  (* The sexp generated by v0 can be parsed as is. *)
  let t' = Dunolint.Config.of_stanzas [ Dunolint.Config.V0.sexp_of_t v0 ] in
  require_equal [%here] (module Dunolint.Config) t t';
  [%expect {||}];
  let () =
    match Dunolint.Config.Private.view t' with
    | `v0 v0' ->
      require_equal [%here] (module Dunolint.Config.V0) v0 v0';
      print_s (Dunolint.Config.sexp_of_t t')
    | `v1 _ -> assert false
  in
  [%expect {| (stanzas ((version 0) ((rules ())))) |}];
  ()
;;

let%expect_test "versioned_sexp v1" =
  let v1 = Dunolint.Config.V1.create [] in
  let t = Dunolint.Config.v1 v1 in
  test_roundtrip t;
  [%expect {| (lang dunolint 1.0) |}];
  print_endline (Dunolint.Config.to_file_contents t ~generated_by:"test_config.ml");
  [%expect
    {|
    ;; This file is generated by [test_config.ml]. Do not edit!
    (lang dunolint 1.0)
    |}];
  let () =
    match Dunolint.Config.Private.view t with
    | `v1 v1' -> require_equal [%here] (module Dunolint.Config.V1) v1 v1'
    | `v0 _ -> assert false
  in
  [%expect {| |}];
  ()
;;

let%expect_test "unsupported version" =
  let sexp = Sexp.List [ List [ Atom "version"; Atom "unknown" ]; List [] ] in
  require_does_raise [%here] (fun () ->
    (Dunolint.Config.of_stanzas [ sexp ] : Dunolint.Config.t));
  [%expect
    {|
    (Of_sexp_error
     "The (version _) syntax is only supported with version 0."
     (invalid_sexp unknown))
    |}];
  ()
;;
