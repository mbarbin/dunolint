In this test we do some linting based on a config.

Let's create some files.

  $ cat > dune-project <<EOF
  > (dune lang 3.17)
  > 
  > (name my_project_name)
  > EOF

  $ cat > dune <<EOF
  > (library
  >  (name mylib)
  >  (libraries a b c))
  > EOF

  $ mkdir -p _build

  $ cat > _build/dune-project <<EOF
  > (dune lang 3.17)
  > 
  > (name ignored_because_in_build)
  > EOF

  $ mkdir -p vendor

  $ cat > vendor/dune-project <<EOF
  > (dune lang 3.17)
  > 
  > (name my_vendor_project_name)
  > EOF

Currently the behavior of the lint-file command is to not load config files on
its own. See below how the name of the project is not linted:

  $ dunolint lint --yes

If the config is supplied, but it is invalid, dunolint will complain.

  $ echo '(blah)' > .dunolint

  $ dunolint lint --yes --config .dunolint 2> /dev/null
  [125]

If there are no rules, the linting will succeed but does nothing in this case.

  $ echo '((rules ()))' > .dunolint

  $ dunolint lint --yes --config .dunolint

Now let's load a config. To make it easier to write in this test, we're
generating an actual config from an OCaml file.

  $ ./lint_file_config_gen.exe > .dunolint

  $ cat .dunolint
  ;; This file is generated by [bin/lint_file_gen_config.ml]. Do not edit!
  ((skip_subtree (cond (((path (glob .git/*)) skip_subtree))))
   (rules
    ((cond
      (((path (glob vendor/*)) return)
       (true (enforce (dune_project (name (equals foo)))))))
     (cond (((path (glob _build/*)) skip_subtree))))))

Let's lint with this config.

  $ dunolint lint --yes --config .dunolint
  Editing file "dune-project":
  -1,3 +1,3
    (dune lang 3.17)
    
  -|(name my_project_name)
  +|(name foo)
