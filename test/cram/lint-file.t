The dunolint command line tool exposes a util to ease integration with editors.
We test it here while calling it from the shell.

Initialize the project root.

  $ ROOT=$(pwd)
  $ touch dune-workspace

By default the command reads from `stdin`.

  $ printf '(lang dune 3.17)\n' | dunolint tools lint-file
  Error: Cannot infer the file kind from the filename "stdin".
  Hint: You may override the filename with the flag [--filename].
  [123]

However, when using the command that way, the linted file kind won't be
inferred. The filename must end with a basename that indicates a supported mode.

  $ printf '(lang dune 3.17)\n' | dunolint tools lint-file --filename=dune-project
  (lang dune 3.17)

By default, the contents is auto-formatted.

  $ printf '(lang\n dune\n 3.17)\n' | dunolint tools lint-file --filename=dune-project
  (lang dune 3.17)

The formatting may however be disabled.

  $ printf '(lang\n dune\n 3.17)\n' \
  > | dunolint tools lint-file --filename=dune-project \
  >   --format-file=false
  (lang
   dune
   3.17)

We note here a point of potential confusion:

1. Dunolint ignores the toplevel stanzas that it does not parse.

The reason for this is to be future proof, and also because we are not going to
necessarily support 100% of dune construct in dunolint, leaving aside those that
offer little linting interest.

2. `dune format-dune-file` works regardless of whether it is called on file
`dune`, or `dune-project`.

What this means for our dunolint command is that a user may be confused into
thinking they have linted their file correctly, based on the fact that it is
correctly formatted, failing to realize that all stanzas are in fact ignored.

See for example:

  $ cat > dune <<EOF
  > (library (name mylib)
  >  (libraries b c a))
  > EOF

Normally, this file would be linted correctly and we'd see the libraries being
re-ordered.

  $ dunolint tools lint-file dune
  (library
   (name mylib)
   (libraries a b c))

However, when reading from `stdin` you have to be careful to select the correct
file kind:

  $ cat dune | dunolint tools lint-file --filename=dune
  (library
   (name mylib)
   (libraries a b c))

Because the following invocation would not crash (per 1.) AND format your file
correct (per 2.) however its stanzas would not be linted.

  $ cat dune | dunolint tools lint-file --filename=dune-project
  (library
   (name mylib)
   (libraries b c a))

The filename provided may be a relative path. When it is used as label only, it
does not have to exists on disk.

  $ cat dune | dunolint tools lint-file --filename=path/to/my/file/dune
  (library
   (name mylib)
   (libraries a b c))

However, it shouldn't be an absolute path, unless it points to a path that is
within the current working directory.

  $ cat dune | dunolint tools lint-file --filename=/path/to/my/file/dune
  Error: Path "/path/to/my/file/dune" is not in dune workspace.
  [123]

  $ cat dune | dunolint tools lint-file --filename=$PWD/path/to/my/file/dune
  (library
   (name mylib)
   (libraries a b c))

When the command fails to parse the file, it complains and exits with a non-zero
code. This should be handled by the logic responsible for the editor
integration.

  $ printf "(invalid sexp\n" | dunolint tools lint-file --filename=dune
  File "dune", line 2, characters 0-0:
  Error: unclosed parentheses at end of input
  [123]

Test invalid lang stanza (missing middle constructor) for dune-project files.

  $ printf '(lang 3.17)\n' > dune-project
  $ dunolint tools lint-file dune-project
  File "dune-project", line 1, characters 0-11:
  1 | (lang 3.17)
      ^^^^^^^^^^^
  Error: Expected (lang dune VERSION) format.
  (lang 3.17)
  [123]

Next we are going to test the command with config.

The command may be passed a config file.

  $ printf '(lang dunolint 1.0)\n' > dunolint

  $ dunolint tools lint dune --config=dunolint
  (library
   (name mylib)
   (libraries a b c))

To make it easier to write in this test, we're generating an actual config from
an OCaml file.

  $ ./lint_file_config_gen.exe --format=v1 > dunolint

  $ dunolint tools lint dune
  (library
   (name mylib)
   (libraries a b c))

  $ cat dunolint
  ;; This file is generated by [bin/lint_file_gen_config.ml]. Do not edit!
  (lang dunolint 1.0)
  
  (skip_paths .git/*)
  
  (skip_paths _build/*)
  
  (rule
   (cond ((path (glob vendor/*)) return)
    (true (enforce (dune_project (name (equals foo)))))))

  $ cat > dune-project <<EOF
  > (lang dune 3.17)
  > 
  > (name my_project_name)
  > EOF

Currently the behavior of the lint-file command is to load a config file on its
own if it is in the current cwd and named "dunolint". See below how the name of
the project is indeed linted. The test config enforces the project name so its
effect is visible in this test (it is changed to "foo"):

  $ dunolint tools lint-file dune-project
  (lang dune 3.17)
  
  (name foo)

However, you may supply a config to use.

  $ printf "(lang dunolint 1.0)\n" > empty-config
  $ dunolint tools lint-file dune-project --config=empty-config
  (lang dune 3.17)
  
  (name my_project_name)

Supplying an absent file or an invalid one results in errors:

  $ dunolint tools lint-file dune-project --config=unknown
  dunolint: option '--config': no 'unknown' file or directory
  Usage: dunolint tools lint-file [OPTION]â€¦ [FILE]
  Try 'dunolint tools lint-file --help' or 'dunolint --help' for more information.
  [124]

  $ dunolint tools lint-file dune-project --config=dune-project
  File "dune-project", line 1, characters 0-16:
  1 | (lang dune 3.17)
      ^^^^^^^^^^^^^^^^
  Error: Dunolint config expected to start with (lang dunolint VERSION).
  [123]

Test that absolute paths work for --config parameter:

  $ ABSCONFIG=$PWD/empty-config
  $ dunolint tools lint-file dune-project --config=$ABSCONFIG
  (lang dune 3.17)
  
  (name my_project_name)

Test with absolute config path from a subdirectory:

  $ mkdir -p subdir
  $ cd subdir
  $ dunolint tools lint-file --filename=dune-project --config=$ABSCONFIG < ../dune-project
  (lang dune 3.17)
  
  (name my_project_name)

Absolute config paths should work even when the config enforces rules:

  $ ABSCONFIG_WITH_RULES=$PWD/../dunolint
  $ dunolint tools lint-file --filename=dune-project --config=$ABSCONFIG_WITH_RULES < ../dune-project
  (lang dune 3.17)
  
  (name foo)
  $ cd ..

Test linting a file using an absolute path:

  $ ABSPATH=$PWD/dune-project
  $ dunolint tools lint-file $ABSPATH
  (lang dune 3.17)
  
  (name foo)

Absolute paths must be within the current workspace root directory:

  $ cd subdir
  $ dunolint tools lint-file $ABSPATH --root .
  Error: Path
  "$TESTCASE_ROOT/dune-project"
  is not in dune workspace.
  [123]

  $ dunolint tools lint-file $ABSPATH
  (lang dune 3.17)
  
  (name foo)

  $ cd ..

The path that is used by the config is the filename supplied when it is
overridden. In particular note how here we are executing the `return` statement
of the config.

  $ dunolint tools lint-file dune-project \
  >   --filename=vendor/dune-project
  (lang dune 3.17)
  
  (name my_project_name)

If the file is at a path configured to be in a skipped directory, the command
won't apply linting rules to it.

  $ cat dune | dunolint tools lint-file --filename=.git/dune --config=empty-config
  (library (name mylib)
   (libraries b c a))

The `.git/` directory is skipped by default, regardless of the config used.

  $ cat dune | dunolint tools lint-file --filename=.git/dune
  (library (name mylib)
   (libraries b c a))

But if the file is not in a default skipped path, we see that it is linted.

  $ cat dune | dunolint tools lint-file --filename=linted/dune
  (library
   (name mylib)
   (libraries a b c))

Test that configs are auto-discovered based on --filename path when reading from stdin.
Create a nested directory with a config that enforces a specific library name:

  $ mkdir -p nested/subdir
  $ cat > nested/dunolint <<EOF
  > (lang dunolint 1.0)
  > (rule (enforce (dune (library (name (equals nested_lib))))))
  > EOF

When reading from stdin with --filename in the nested directory, the nested config
should be loaded:

  $ printf '(library (name test))' | dunolint tools lint-file --filename=nested/subdir/dune
  (library
   (name nested_lib))

But when --filename points to a different directory, the nested config should not apply.
Note that the root dunolint config still applies (sorting libraries):

  $ printf '(library (name test) (libraries z a))' | dunolint tools lint-file --filename=other/dune
  (library
   (name test)
   (libraries a z))

The lint result may be saved directly to the input file with the flag
`--in-place`. There are a few corner cases to cover here, such as what happens
when the filename is overridden. The intention is to target the actual input
file when provided.

  $ cat dune
  (library (name mylib)
   (libraries b c a))

  $ cat dune | dunolint tools lint-file --in-place
  Error: The flag [in-place] may only be used when the input is read from a
  regular file.
  [124]

The command shall not create non-existing files when the filename is overridden.

  $ cat dune | dunolint tools lint-file --in-place --filename=path/to/dune
  Error: The flag [in-place] may only be used when the input is read from a
  regular file.
  [124]

  $ dunolint tools lint-file absent --in-place --filename=dune
  Error: No such file "absent".
  [123]

We only support regular files with this option.

  $ ln -sf dune dune-link

  $ dunolint tools lint-file dune-link --in-place --filename=dune
  Error: Linted file "dune-link" is expected to be a regular file.
  Actual file kind is [Symbolic link].
  [123]

  $ mkdir bogus

  $ dunolint tools lint-file bogus --in-place --filename=dune
  Error: Linted file "bogus" is expected to be a regular file.
  Actual file kind is [Directory].
  [123]

We make sure to test that when both the file and an override are supplied, the
contents is saved in the input file and not at the overridden path.

  $ dunolint tools lint-file dune --in-place --filename=path/to/dune

  $ cat dune
  (library
   (name mylib)
   (libraries a b c))

This should not have created a file with the given filename.

  $ test -e path/to/dune
  [1]

The command is idempotent.

  $ cp dune dune-backup

  $ dunolint tools lint-file dune --in-place

  $ diff dune dune-backup

Test linting a file from outside the dune workspace. This should work and
re-order the libraries without error.

  $ NO_WORKSPACE=$(mktemp -d)

  $ cat > ${NO_WORKSPACE}/dune <<EOF
  > (library (name mylib)
  >  (libraries c b a))
  > EOF

  $ (cd ${NO_WORKSPACE} && dunolint tools find-workspace-root)
  Error: I cannot find the root of the current dune workspace/project.
  If you would like to create a new dune project, you can type:
  
      dune init project NAME
  
  Otherwise, please make sure to run dune inside an existing project or
  workspace. For more information about how dune identifies the root of the
  current workspace/project, please refer to
  https://dune.readthedocs.io/en/stable/usage.html#finding-the-root
  [123]

  $ (cd ${NO_WORKSPACE} && dunolint tools lint-file dune)
  (library
   (name mylib)
   (libraries a b c))

Verify that the command works when run from $NO_WORKSPACE directly when reading
from stdin with filename override:

  $ cd ${NO_WORKSPACE}
  $ cat dune | dunolint tools lint-file --filename=dune
  (library
   (name mylib)
   (libraries a b c))
  $ cd ${ROOT}
  $ rm -rf ${NO_WORKSPACE}

Test precedence: deeper configs should override shallower configs.
When a file is affected by multiple configs (root and nested), rules from deeper
configs should be applied after (and thus override) rules from shallower configs.

Create an isolated test directory to avoid conflicts:

  $ mkdir -p precedence-test-dir/deeper
  $ cd precedence-test-dir

Create a workspace marker and root config that enforces (is_prefix root):

  $ touch dune-workspace
  $ cat > dunolint <<EOF
  > (lang dunolint 1.0)
  > 
  > (rule
  >  (enforce
  >   (dune_project
  >    (name (is_prefix root)))))
  > EOF

Create a nested config that enforces (is_prefix nested):

  $ cat > deeper/dunolint <<EOF
  > (lang dunolint 1.0)
  > 
  > (rule
  >  (enforce
  >   (dune_project
  >    (name (is_prefix nested)))))
  > EOF

Create a test dune-project file:

  $ cat > test-project <<EOF
  > (lang dune 3.17)
  > (name original)
  > EOF

When linting a file at the root, only the root config applies:

  $ dunolint tools lint-file test-project --filename=dune-project --root .
  (lang dune 3.17)
  
  (name rootoriginal)

When linting a file in the nested directory, both configs apply.
The root config's (is_prefix root) is applied first, then the nested config's
(is_prefix nested) is applied, resulting in "nestedrootoriginal":

  $ dunolint tools lint-file test-project --filename=deeper/dune-project --root .
  (lang dune 3.17)
  
  (name nestedrootoriginal)

This demonstrates that:
1. Both configs are discovered and applied
2. The deeper config's rules are applied last (nested after root)
3. Rules compose correctly with deeper configs taking precedence

  $ cd ..
